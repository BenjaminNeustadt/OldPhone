= OldPhone Coding Challenge
Benjamin Neustadt
:source-highlighter: rouge
:document-type: article
// URLs:
:url-csharp-version: https://github.com/BenjaminNeustadt/OldPhone_csharp
:url-ruby-documentation: https://www.ruby-lang.org/en/documentation/
:url-extraction-branch: https://github.com/BenjaminNeustadt/OldPhone/tree/redesign_into_class_2
:url-rspec-documentation: https://rspec.info/
:toc:

OldPhonePad is a program to decode number values using the same digit into their correlating letter, punctuation and space values.
The method `oldphone` takes a string as an argument and returns the correct output corresponding to number inputs.

Key documentation

* {url-ruby-documentation}[Ruby Documentation]
* {url-rspec-documentation}[RSpec]


****
*See the C# answer to this exercise {url-csharp-version}[here].*
****

== Usage
.*Installation*

* Git clone this repository:
[source,shell]
----
 git clone https://github.com/BenjaminNeustadt/OldPhone.git
----

* Install the gems:
[source,shell]
----
 bundle install
----

* Run the tests:
[source,shell]
----
 rspec
----

.*Program Usage*

* To use the program open the Ruby REPL with the path of your local copy:
[source,shell]
----
irb -r ./lib/oldphone.rb
----
* To run the program in the REPL:
[source,shell]
----
oldphone("[a string of valid numbers]")<1>
----
<1> When using the same number for different letters under that button, or the same letter twice, use a space in between.

== Process Thoughts

There is currently one method, `oldphone`, the public facing interface method.
It calls a class called `Transform` that holds all of the business logic.  The
design is such that other methods could also utilize the logic that `Transform`
class holds.  The user therefore only interacts with `oldphone`, although the
business logic does not happen on `oldphone`, but rather behind the scenes on
the backend `Transform` class. `oldphone` is therefore like the view, that
presents the output to us.

The testing framework used is {url-rspec-documentation}[RSpec].

The logic was first designed inside `oldphone` and then extracted into separate
methods in a class that also holds a module with the first of what could be
many regular expressions. A constant called `morpheme_dictionary` holds the
number-letter attributes.

The only thing left to do on this is slightly modify the tests to include
`Transform`, as currently the tests only test the public facing interface
`oldphone`.


== Original Instructions

[.text-center]
****

[source, markdown]
----
┌───────┬───────┬───────┐
│       │       │       │
│   1   │   2   │   3   │
│  &'(  │  ABC  │  DEF  │
│       │       │       │
├───────┼───────┼───────┤
│       │       │       │
│   4   │   5   │   6   │
│  GHI  │  JKL  │  MNO  │
│       │       │       │
├───────┼───────┼───────┤
│       │       │       │
│   7   │   8   │   9   │
│ PQRS  │  TUV  │ WXYZ  │
│       │       │       │
├───────┼───────┼───────┤
│       │       │       │
│   *   │   0   │   #   │
│   ←   │   ␣   │   →   │
└───────┴───────┴───────┘
----

****

Here is an old phone keypad with alphabetical letters, a
backspace key, and a send button.

Each button has a number to identify it and pressing a button multiple
times will cycle through the letters on it allowing each button to
represent more than one letter.

For example, pressing 2 once will return ‘A’ but pressing twice in
succession will return ‘B’.

You must pause for a second in order to type two characters from the
same button after each other: “222 2 22” -> “CAB”.


****
.*The Directions*
[source, md]
----
Please design and document a class of method that will turn any input to <1>
OldPhonePad into the correct output.
Assume that a send (represented as a literally the _#_) will always be included at the end of every input. <2>
----
<1> Is the "class of method" supposed to read "class or method"?
    This word, I think should be "or" instead, and I have applied this assumption before I have asked for confirmation.
<2> What to do if additional information is found after the "send" is described in the writing below.

As an unspecified behaviour,
if we reach the pound sign and find more characters after that pound sign
(the signal to send) we will send everything up until then,
and ignore any input after that signal.

****

[source, ruby]
----
def oldphonepad (input)
  # Please write your implementation here!
end
----

== *Examples*

[source, ruby]
----
oldphonepad(“33#”) # => output: E
oldpgonepad(“227*#”) # => output: B
oldpgonepad(“4433555 555666#”) # => output: HELLO
oldpgonepad(“8 88777444666*664#”) # => output: ?????
----

== Approach

=== keypad values

|===
| sequence letter | sequence letter | sequence letter

^| 1 &  ^| 11 '  ^| 111 (
^| 2 a  ^| 22 b  ^| 222 c
^| 3 d  ^| 33 e  ^| 333 f

^| 4 g  ^| 44 h  ^| 444 i
^| 5 j  ^| 55 k  ^| 555 l
^| 6 m  ^| 66 n  ^| 666 o

^| 7 p  ^| 77 q  ^| 777 r 7777 s
^| 8 t  ^| 88 u  ^| 888 v
^| 9 w  ^| 99 x  ^| 999 y 9999 z

|===
